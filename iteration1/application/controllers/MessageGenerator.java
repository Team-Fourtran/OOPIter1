package application.controllers;


import java.util.*;

import application.models.playerAsset.*;


class MessageGenerator implements KeyPressListener{
    private ArrayList<Mode> modes = new ArrayList<Mode>();
    private Mode currentMode;
    private int modeIndex;	//Originally used ListIterator, but the Java List interface iterators are garbage

    //A set of assetIterators for the current player's assets
    protected HashMap<String, ListIterator> assetIterators;

    private Controller receiver;

    MessageGenerator(Controller receiver, KeyPressInformer keyInformer, HashMap<String, ListIterator> assetIterators){
        initializeModes();
        this.assetIterators = assetIterators;
        this.receiver = receiver;
        keyInformer.registerClient(this);   //Register self to listen to updates in the keys pressed
        updateIterators(assetIterators);           //Update the asset iterators initially

    }

    public String getStatus(){
        return this.currentMode.toString();
    }

    //Gets called when player turn switches. Changes the iterators on hand.
    protected void updateIterators(HashMap<String, ListIterator> assetIterators){
        this.assetIterators = assetIterators;
    }

    @Override //Listen to notifications from a KeyPressInformer
    public void updateKeysPressed(HashMap<String, Boolean> kp) {
        interpretKeystrokes(kp);
    }

    private void updatePanelWithStatus(){
        receiver.updatePanelWithStatus(getStatus());
    }
    private void interpretKeystrokes(HashMap<String, Boolean> keystrokes){



        if(keystrokes.get("ENTER")){
            generateMessage();          //Submit the message
        }

        if(keystrokes.get("CONTROL")){
            //Cycle MODE
            if(keystrokes.get("UP")){
                nextMode();
                //DEBUG:
                updatePanelWithStatus();
            } else if(keystrokes.get("DOWN")){
                previousMode();
                //DEBUG:
                updatePanelWithStatus();
            }

            //Cycle TYPE
            else if(keystrokes.get("LEFT")){
                this.currentMode.controlLeft();			//Forward to Mode
                //DEBUG:
                updatePanelWithStatus();
            } else if(keystrokes.get("RIGHT")){
                this.currentMode.controlRight();		//Forward to Mode
                //DEBUG:
                updatePanelWithStatus();
            }

        } else {
            if(keystrokes.get("UP")){
                this.currentMode.upKey();          		//Forward to Mode
                //DEBUG:
                updatePanelWithStatus();
            } else if(keystrokes.get("DOWN")){
                this.currentMode.downKey();		    	//Forward to Mode
                //DEBUG:
                updatePanelWithStatus();
            }

            //Cycle TYPE
            else if(keystrokes.get("LEFT")){
                this.currentMode.leftKey(); 			//Forward to Mode
                //DEBUG:
                updatePanelWithStatus();
            } else if(keystrokes.get("RIGHT")){
                this.currentMode.rightKey();    		//Forward to Mode
                //DEBUG:
                updatePanelWithStatus();
            }
        }
    }

    //Send the command to the receiver, as generated by the currentMode
    private void generateMessage(){
        receiver.handleMsg(this.currentMode.generateMessage());
    }

    //Set up the mode list initially
    private void initializeModes(){
        //Fill this.modes with the 4 modes
        this.modes.add((Mode) new RallyPointMode(this));
        this.modes.add((Mode) new StructureMode(this));
        this.modes.add((Mode) new UnitMode(this));
        this.modes.add((Mode) new ArmyMode(this));

        //Initialize currentMode
        this.modeIndex = 0;
        this.currentMode = (Mode) this.modes.get(modeIndex);
    }

    //Switches the mode to the next mode on the list, looping back around when the end is reached.
    private void nextMode(){
        this.modeIndex = Utils.mod(this.modeIndex + 1,this.modes.size());
        this.currentMode = (Mode) modes.get(modeIndex);
    }

    //Switches the mode to the previous mode on the list, looping back around when the beginning is reached.
    private void previousMode(){
        this.modeIndex = Utils.mod(this.modeIndex - 1,this.modes.size());
        this.currentMode = (Mode) modes.get(modeIndex);
    }
}

//Define the set of methods that a mode must implement
interface Mode{
    String generateMessage();

    void controlLeft();
    void controlRight();


    void upKey();
    void downKey();

    void leftKey();
    void rightKey();

    String toString(); //e.g. "UNIT/ARMY/STRUCTURE/RALLY POINT"
}


class UnitMode implements Mode{
    private ArrayList<String> unitTypes = new ArrayList<String>();  //A list of the possible types of units
    private String currentType;         //The Unit type currently selected
    private int currentTypeIndex;       //The index in the ArrayList of that type

    MessageGenerator owner;             //The parent MessageGenerator who provides PlayerAssetIterators

    //Define a set of the possible commands that a Unit might issue
    String[] commands = {"REINF","DECOM","PWDOWN","PWUP"};
    int command_index = 0;  //Will determine which command is currently selected

    //Will hold the UnitID of the currently-selected Unit.
    String unitId;

    /* Commands will be generated in the format CMD_UnitID by concatenating the above variables */

    //Constructor for a UnitMode: Takes in an owner, who will provide iterators
    UnitMode(MessageGenerator owner){
        //Define the owner MessageGenerator
        this.owner = owner;

        //Define the possible Unit types
        this.unitTypes.add("Explorer");
        this.unitTypes.add("Colonist");
        this.unitTypes.add("Melee");
        this.unitTypes.add("Ranged");

        //Initialize the currentType to the 0th element in the ArrayList
        this.currentTypeIndex = 0;
        this.currentType = unitTypes.get(currentTypeIndex);

        //if(owner.assetIterators.get("unit").hasNext())
            //unitId = owner.assetIterators.get("unit").next().getID();
        //else
            unitId = "None";
    }

    public String toString(){
        return "Mode: UNIT | Type: " + currentType.toString() + " | Command: " + commands[command_index] + " | UnitID: " + unitId;
    }

    public String generateMessage(){
        return commands[command_index] + "_" + unitId;
    }

    @Override //Cycle to previous type
    public void controlLeft() {
        this.currentTypeIndex = Utils.mod(currentTypeIndex - 1, this.unitTypes.size());
        this.currentType = this.unitTypes.get(this.currentTypeIndex);
        rightKey();
        rightKey();
    }

    @Override //Cycle to next type
    public void controlRight() {
        this.currentTypeIndex = Utils.mod(currentTypeIndex + 1, this.unitTypes.size());
        this.currentType = this.unitTypes.get(this.currentTypeIndex);
        rightKey();
        rightKey();
    }

    @Override
    public void upKey() {
        command_index = Utils.mod((command_index+1), commands.length);
    }

    @Override
    public void downKey() {
        command_index = Utils.mod((command_index-1), commands.length);
    }

    @Override
    public void leftKey() {
        ListIterator unitIterator = owner.assetIterators.get("unit");
        Unit prevUnit = findNextElement("LEFT", unitIterator);
        unitId = prevUnit.getID();
    }

    @Override
    public void rightKey() {
        ListIterator unitIterator = owner.assetIterators.get("unit");
        Unit prevUnit = findNextElement("RIGHT", unitIterator);
        unitId = prevUnit.getID();
    }

    private Unit findNextElement(String direction, ListIterator unitIterator){
        int startIndex; //Will be used to detect if we've iterated through all the Units

        //If there's a previous unit, startIndex is that unit's index
        if(unitIterator.hasPrevious())
            startIndex = unitIterator.previousIndex();

            //If there's a next unit, startIndex is that unit's index
        else if(unitIterator.hasNext())
            startIndex = unitIterator.nextIndex();

            //If there's neither a next nor a previous unit, return null, as there's no units to find
        else return null;

        //If this was called from leftKey()
        if(direction.equals("LEFT")){
            Unit prevUnit = null;
            do{
                //If there's a previous element, assign it to prevUnit
                if(unitIterator.hasPrevious()){
                    prevUnit = (Unit) unitIterator.previous();
                }

                //If there is no previous element, iterate through the end of the list and get the last element
                else{
                    while(unitIterator.hasNext()) {
                        prevUnit = (Unit) unitIterator.next();
                    }
                }
                //If the previous unit was assigned, and it's of the current type, return it
                if(prevUnit != null && prevUnit.getType().equals(currentType))
                    return prevUnit;

                //Otherwise, continue looking
                else continue;

            }
            //Stop once we've returned to the starting index
            while(unitIterator.previousIndex() != startIndex);

            return prevUnit;    //Returns null if it wasn't assigned
        }

        //Else, if this was called from rightKey()
        else if(direction.equals("RIGHT")){
            Unit nextUnit = null;
            do{
                //If there's a next element, assign it to nextUnit
                if(unitIterator.hasNext()){
                    nextUnit = (Unit) unitIterator.next();
                }

                //If there is no next element, iterate through to the start of the list and get the first element
                else{
                    while(unitIterator.hasPrevious()) {
                        nextUnit = (Unit) unitIterator.previous();
                    }
                }
                //If the next unit was assigned, and it's of the current type, return it
                if(nextUnit != null && nextUnit.getType().equals(currentType))
                    return nextUnit;

                //Otherwise, continue looking
                else continue;

            }
            //Stop once we've returned to the starting index
            while(unitIterator.previousIndex() != startIndex);

            return nextUnit;    //Returns null if it wasn't assigned
        }

        //Failsafe: Return null
        else return null;
    }
}

class StructureMode implements Mode{
    MessageGenerator owner;

    String[] commands = {"MAKE","HEAL","DECOM","PWDWN","PWUP","CLEARQ"};
    int command_index = 0;      //Will determine which command is currently selected
    String structureId = "None";     //will hold the ID of the selected structure

    StructureMode(MessageGenerator owner){
        this.owner = owner;
    }

    public String toString(){
        return "Mode: STRUCTURE | Command: " + commands[command_index] + " | StructureID: " + structureId;
    }

    public String generateMessage(){
        return commands[command_index] + "_" + structureId;
    }

    @Override
    public void controlLeft() {
        // TODO Implement different structure types
    }

    @Override
    public void controlRight() {
        // TODO Implement different strucure types
    }

    @Override
    public void upKey() {
        command_index = Utils.mod((command_index+1), commands.length);
    }

    @Override
    public void downKey() {
        command_index = Utils.mod((command_index+1), commands.length);
    }

    @Override
    public void leftKey(){
        ListIterator structureIterator = owner.assetIterators.get("structure");
        if(structureIterator.hasPrevious()){
            structureId = ((Structure) owner.assetIterators.get("structure").previous()).getID();
        }
    }

    @Override
    public void rightKey() {
        ListIterator structureIterator = owner.assetIterators.get("structure");
        if(structureIterator.hasNext()){
            structureId = ((Structure) owner.assetIterators.get("structure").next()).getID();
        }
    }
}

class RallyPointMode implements Mode{
    MessageGenerator owner;

    RallyPointMode(MessageGenerator owner){
        this.owner = owner;
    }

    public String toString(){
        return "Mode: RALLY POINT";
    }

    public String generateMessage(){
        return "Generated message: " + this.toString();
    }

    @Override // Nothing happens
    public void controlLeft() { }

    @Override // Nothing happens
    public void controlRight() { }

    @Override
    public void upKey() {

    }

    @Override
    public void downKey() {

    }

    @Override
    public void leftKey() {

    }

    @Override
    public void rightKey() {

    }
}

class ArmyMode implements Mode{
    private ArrayList<Mode> subModes = new ArrayList<Mode>();
    private Mode currentSubMode = new EntireArmyMode();
    private int subModeIndex;
    MessageGenerator owner;

    ArmyMode(MessageGenerator owner) {
        this.owner = owner;
        subModes.add(new EntireArmyMode());
        subModes.add(new BattleGroupMode());
        subModes.add(new ReinforcementMode());

        subModeIndex = 0;
        currentSubMode = subModes.get(subModeIndex);
    }

    public String toString(){
        return "Mode: ARMY\tSubmode: " + this.currentSubMode.toString();
    }

    public String generateMessage(){
        return "Generated message: " + this.toString();
    }

    @Override //Cycle to previous submode
    public void controlLeft() {
        this.subModeIndex = Utils.mod(subModeIndex - 1, this.subModes.size());
        this.currentSubMode = this.subModes.get(this.subModeIndex);
    }

    @Override //Cycle to next submode
    public void controlRight() {
        this.subModeIndex = Utils.mod(subModeIndex + 1, this.subModes.size());
        this.currentSubMode = this.subModes.get(this.subModeIndex);
    }

    @Override
    public void upKey() {

    }

    @Override
    public void downKey() {

    }

    @Override
    public void leftKey() {

    }

    @Override
    public void rightKey() {

    }
}

class EntireArmyMode implements Mode{
    public String toString(){
        return "ENTIRE ARMY";
    }

    public String generateMessage(){
        return this.toString();
    }

    @Override //Unused - Taken care of by parent ArmyMode
    public void controlLeft() {}

    @Override //Unused - Taken care of by parent ArmyMode
    public void controlRight() {}

    @Override
    public void upKey() {

    }

    @Override
    public void downKey() {

    }

    @Override
    public void leftKey() {

    }

    @Override
    public void rightKey() {

    }

    EntireArmyMode(){

    }
}

class BattleGroupMode implements Mode{
    public String toString(){
        return "BATTLEGROUP";
    }

    public String generateMessage(){
        return this.toString();
    }

    @Override //Unused - Taken care of by parent ArmyMode
    public void controlLeft() {}

    @Override //Unused - Taken care of by parent ArmyMode
    public void controlRight() {}

    @Override
    public void upKey() {

    }

    @Override
    public void downKey() {

    }

    @Override
    public void leftKey() {

    }

    @Override
    public void rightKey() {

    }

    BattleGroupMode(){

    }
}

class ReinforcementMode implements Mode{
    public String toString(){
        return "REINFORCEMENT";
    }

    public String generateMessage(){
        return this.toString();
    }

    @Override //Unused - Taken care of by parent ArmyMode
    public void controlLeft() {}

    @Override //Unused - Taken care of by parent ArmyMode
    public void controlRight() {}

    @Override
    public void upKey() {

    }

    @Override
    public void downKey() {

    }

    @Override
    public void leftKey() {

    }

    @Override
    public void rightKey() {

    }

    ReinforcementMode(){

    }
}

//Custom operations to deal with some quirks
class Utils{
    //Different interpretation of mod for negative numbers.
    //Necessary for circular iteration through modes/types etc.
    public static int mod(int i, int n){
        return (i >= 0) ? (i%n) : (n+i);
    }
}