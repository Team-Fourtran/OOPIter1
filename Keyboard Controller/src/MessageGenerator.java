import java.util.ArrayList;
import java.util.ListIterator;
import java.util.Scanner;


public class MessageGenerator {
	private ArrayList<Mode> modes = new ArrayList<Mode>();
	
	private Mode currentMode;
	private int modeIndex;	//Originally used ListIterator, but the Java List interface iterators are garbage
	
	private Controller receiver; 
	
	public MessageGenerator(Controller receiver){
		initializeModes();
		this.receiver = receiver;
		System.out.println(this.modes);
		listenToKeyboard();
	}
	
	private void listenToKeyboard(){
		//Runs perpetually
		System.out.println("Syntax:\n\t'UP','DOWN','LEFT','RIGHT','CONTROL','ENTER'\n\t(Space-separated)");
		Scanner s = new Scanner(System.in);
		
		while(true){
			/*TODO: Get actual keyboard input. For now just prompts for keystrokes */
			System.out.println("\n\nEnter simulated keystrokes: ");
			ArrayList<String> keystrokes = new ArrayList<String>();
			String[] tempS = s.nextLine().split(" ");
			for(int i = 0; i < tempS.length; i++)
				keystrokes.add(tempS[i]);
			
			//Enter key and nothing else == "Submit"
			if(keystrokes.contains("ENTER") && keystrokes.size() == 1){
				generateMessage();
			}
			
			if(keystrokes.contains("CONTROL")){
				//Cycle MODE
				if(keystrokes.contains("UP")){
					nextMode();
				} else if(keystrokes.contains("DOWN")){
					previousMode();
				} 
				
				//Cycle TYPE
				else if(keystrokes.contains("LEFT")){
					this.currentMode.controlLeft();			//Forward to Mode
				} else if(keystrokes.contains("RIGHT")){
					this.currentMode.controlRight();		//Forward to Mode
				}
				
			}
			
			
		}
	}
	
	protected void generateMessage(){
		//Sends receiver a message as generated by the current Mode
		receiver.handleMsg(this.currentMode.generateMessage());
	}
	
	private void initializeModes(){
		//Fill this.modes with the 4 modes
		this.modes.add((Mode) new RallyPointMode());
		this.modes.add((Mode) new StructureMode());
		this.modes.add((Mode) new UnitMode());
		this.modes.add((Mode) new ArmyMode());
		
		//Initialize currentMode
		this.modeIndex = 0;
		this.currentMode = this.modes.get(modeIndex);
	}
	
	//Switches the mode to the next mode on the list, looping back around when the end is reached.
	private void nextMode(){
		this.modeIndex = Utils.mod(this.modeIndex + 1,this.modes.size());
		this.currentMode = modes.get(modeIndex);
	}
	
	//Switches the mode to the previous mode on the list, looping back around when the beginning is reached.
	private void previousMode(){
		this.modeIndex = Utils.mod(this.modeIndex - 1,this.modes.size());
		this.currentMode = modes.get(modeIndex);
	}
}

interface Mode{
	String generateMessage();

	
	void controlLeft();
	void controlRight();
	
	/*
	void upKey();
	void downKey();
	
	void leftKey();
	void rightKey();
	*/
	
	public String toString();
}

class UnitMode implements Mode{
	private ArrayList<String> unitTypes = new ArrayList<String>();
	private String currentType;
	private int currentTypeIndex;
	public UnitMode(){
		this.unitTypes.add("Explorer");
		this.unitTypes.add("Colonist");
		this.unitTypes.add("Melee Unit");
		this.unitTypes.add("Ranged Unit");
		
		this.currentTypeIndex = 0;
		this.currentType = unitTypes.get(currentTypeIndex);
	}
	
	public String toString(){
		return "Mode: Unit\tType:" + this.currentType + "(" + currentTypeIndex + ")";
	}
	
	public String generateMessage(){
		return "Generated message: " + this.toString();
	}

	@Override //Cycle to previous type
	public void controlLeft() {
		this.currentTypeIndex = Utils.mod(currentTypeIndex - 1, this.unitTypes.size());
		this.currentType = this.unitTypes.get(this.currentTypeIndex);
	}

	@Override //Cycle to next type
	public void controlRight() {
		this.currentTypeIndex = Utils.mod(currentTypeIndex + 1, this.unitTypes.size());
		this.currentType = this.unitTypes.get(this.currentTypeIndex);
	}
}

class StructureMode implements Mode{
	public String toString(){
		return "I am in Structure Mode";
	}
	
	public String generateMessage(){
		return "Generated message: " + this.toString();
	}

	@Override
	public void controlLeft() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void controlRight() {
		// TODO Auto-generated method stub
		
	}
}

class RallyPointMode implements Mode{
	public String toString(){
		return "I am in RallyPoint Mode";
	}
	
	public String generateMessage(){
		return "Generated message: " + this.toString();
	}

	@Override
	public void controlLeft() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void controlRight() {
		// TODO Auto-generated method stub
		
	}
}

class ArmyMode implements Mode{
	private ArrayList<Mode> subModes = new ArrayList<Mode>();
	private Mode currentSubMode = new EntireArmyMode();
	
	public String toString(){
		return currentSubMode.toString();
	}
	
	public String generateMessage(){
		return "Generated message: " + this.toString();
	}

	@Override
	public void controlLeft() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void controlRight() {
		// TODO Auto-generated method stub
		
	}
}

class EntireArmyMode implements Mode{
	public String toString(){
		return "I am in EntireArmy Mode";
	}
	
	public String generateMessage(){
		return "Generated message: " + this.toString();
	}

	@Override
	public void controlLeft() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void controlRight() {
		// TODO Auto-generated method stub
		
	}
}

class BattleGroupMode implements Mode{
	public String toString(){
		return "I am in BattleGroup Mode";
	}
	
	public String generateMessage(){
		return "Generated message: " + this.toString();
	}

	@Override
	public void controlLeft() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void controlRight() {
		// TODO Auto-generated method stub
		
	}
}

class ReinforcementMode implements Mode{
	public String toString(){
		return "I am in Reinforcement Mode";
	}
	
	public String generateMessage(){
		return "Generated message: " + this.toString();
	}

	@Override
	public void controlLeft() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void controlRight() {
		// TODO Auto-generated method stub
		
	}
}

//Custom operations to deal with some quirks
class Utils{
	//Different interpretation of mod for negative numbers.
	//Necessary for circular iteration through modes/types etc.
	public static int mod(int i, int n){
		return (i >= 0) ? (i%n) : (n+i);
	}
}